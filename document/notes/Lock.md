## Locks

### ReentrantLock（重入锁）

java除了使用关键字synchronized外，还可以使用ReentrantLock实现独占锁的功能。而且ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。

#### ReentrantLock与Synchronized

1. synchronized是独占锁，加锁和解锁的过程自动进行，易于操作，但不够灵活。ReentrantLock也是独占锁，加锁和解锁的过程需要手动进行，不易操作，但非常灵活。

2. synchronized可重入，因为加锁和解锁自动进行，不必担心最后是否释放锁；ReentrantLock也可重入，但加锁和解锁需要手动进行，且次数需一样，否则其他线程无法获得锁。

3. synchronized不可响应中断，一个线程获取不到锁就一直等着；ReentrantLock可以相应中断。

ReentrantLock还可以实现公平锁机制。什么叫公平锁呢？也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁。

### synchronized（关键字）
- 参考文档[Synchronized实现原理](https://blog.csdn.net/jinjiniao1/article/details/91546512)
- 参考文档[深入理解Synchronized实现原理](https://www.jianshu.com/p/46a874d52b71)
- 参考文档[Java Guide](https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-3Java%E5%A4%9A%E7%BA%BF%E7%A8%8B?id=_2311-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97)
- [并发编程](http://concurrent.redspider.group/RedSpider.html)

对象在内存中的存储布局方式可以分为3块区域：对象头、实例数据、对齐填充。

- 对象头包含两部分，第一部分是Mark Word，用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等，这一部分占一个字节。第二部分是Klass Pointer（类型指针），是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，这部分也占一个字节。(如果对象是数组类型的，则需要3个字节来存储对象头，因为还需要一个字节存储数组的长度)
- 实例数据存放的是类属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
- 填充数据是因为虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。


对象头包括：锁状态标志、线程持有的锁
synchronized的实现原理和应用总结
（1）synchronized同步代码块：
synchronized关键字经过编译之后，会在同步代码块前后分别形成monitorenter和monitorexit字节码指令。
在执行monitorenter指令的时候，首先尝试获取对象的锁，如果这个锁没有被锁定或者当前线程已经拥有了那个对象的锁，锁的计数器就加1，
在执行monitorexit指令时会将锁的计数器减1，当减为0的时候就释放锁。如果获取对象锁一直失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。
（2）同步方法：方法级的同步是隐式的，无须通过字节码指令来控制，JVM可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用的时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先持有monitor对象，然后才能执行方法，最后当方法执行完（无论是正常完成还是非正常完成）时释放monitor对象。在方法执行期间，执行线程持有了管程，其他线程都无法再次获取同一个管程。


1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 
3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 
4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

## 锁升级=锁膨胀、锁膨胀（锁升级）总结
JDK1.6之前synchronized使用的是重量级锁，JDK1.6之后进行了优化，拥有了无锁->偏向锁->轻量级锁->重量级锁的升级过程，而不是无论什么情况都使用重量级锁。
- 无锁：MarkWord标志位01，没有线程执行同步方法/代码块时的状态。
- 偏向锁：MarkWord标志位01（和无锁标志位一样）。偏向锁是通过在bitfields中通过CAS设置当前正在执行的ThreadID来实现的。假设线程A获取偏向锁执行代码块（即对象头设置了ThreadA_ID），线程A同步块未执行结束时，线程B通过CAS尝试设置ThreadB_ID会失败，因为存在锁竞争情况，这时候就需要升级为轻量级锁。注：偏向锁是针对于不存在资源抢占情况时候使用的锁，如果被synchronized修饰的方法/代码块竞争线程多可以通过禁用偏向锁来减少一步锁升级过程。可以通过JVM参数-XX:-UseBiasedLocking = false来关闭偏向锁。
- 轻量级锁：MarkWord标志位00。轻量级锁是采用自旋锁的方式来实现的，自旋锁分为固定次数自旋锁和自适应自旋锁。轻量级锁是针对竞争锁对象线程不多且线程持有锁时间不长的场景, 因为阻塞线程需要CPU从用户态转到内核态，代价很大，如果一个刚刚阻塞不久就被释放代价有大。具体实现和升级为重量级锁过程：线程A获取轻量级锁时会把对象头中的MarkWord复制一份到线程A的栈帧中创建用于存储锁记录的空间DisplacedMarkWord，然后使用CAS将对象头中的内容替换成线程A存储DisplacedMarkWord的地址。如果这时候出现线程B来获取锁，线程B也跟线程A同样复制对象头的MarkWord到自己的DisplacedMarkWord中，如果线程A锁还没释放，这时候那么线程B的CAS操作会失败，会继续自旋，当然不可能让线程B一直自旋下去，自旋到一定次数（固定次数/自适应）就会升级为重量级锁。
- 重量级锁：通过对象内部监视器（monitor）实现，monitor本质前面也提到了是基于操作系统互斥（mutex）实现的，操作系统实现线程之间切换需要从用户态到内核态切换，成本非常高。
> 注：锁只可以升级不可以降级，但是偏向锁可以被重置为无锁状态。

1. 是什么？

    执行到synchronized关键字时，锁对象由偏向锁->轻量级锁->重量级锁的演化；
2.  各阶段

    - 偏向锁：刚执行到Synchronized关键字时的锁对象为偏向锁（偏向第一个申请到它的线程）（通过CAS操作修改对象头里的锁标志位），当该线程执行完之后，锁不会被释放；当第二次执行到同步代码块时，线程会判断当前持有锁的线程是否就是自己（对象头里有持有锁的线程ID），若是则继续往下执行，不需要重新加锁；若不是，则会把偏向锁升级为轻量级锁。
    - 轻量级锁: 当有第二个线程加入锁竞争时，偏向锁就会升级为轻量级锁。轻量级锁是自旋锁，即当一个线程申请锁而不得时，该线程就会进入自旋（为什么是自旋而不是挂起呢？因为挂起和恢复需要在用户态和内核态之间切换，会造成较大的开销，而短时间的自旋开销更小，不需要切换状态）。
    - 重量级锁：若某线程忙等次数过多大于设置的阈值，说明锁竞争情况严重（长时间的自旋会造成CPU资源的浪费，开销变大），因此这个达到最大自旋次数的线程就会将轻量级锁升级为重量级锁（CAS操作修改锁标志位），将自己挂起，放弃CPU,等待未来被唤醒。
3. 另外

    - 偏向锁和轻量级锁都是乐观锁，重量级锁为悲观锁；
    - jdk1.6之后引入的锁膨胀，原来都是直接使用重量级锁。


### 死锁
#### 产生死锁的四个必要条件？
1. 互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
2. 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
3. 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
4. 环路等待条件：是指进程发生死锁后，必然存在一个进程--资源之间的环形链

#### 避免死锁的方法：
1. 破坏“互斥”条件:就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。但一般“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他三个必要条件，而不去涉及破坏“互斥”条件。
2. 破坏“请求和保持”条件:在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。

#### 死锁总结
- 参考文档：[用个通俗的例子讲一讲死锁](https://zhuanlan.zhihu.com/p/26945588)

- 死锁发生的条件：

①、**资源互斥，一个资源只能一个线程获得。**

②、**请求与保持，占用一个资源，并等待其他资源才能执行。**

③、**不可抢占，已经占有，别人不能抢夺。**

④、**循环等待，你占有一个，别人占有另一个，都相互等待对方的资源。**

- 避免死锁的方式，一般有几种办法：

1. **一次性申请所有的资源**，这样就不存在等待了。
2. **先归还锁再等待**，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **指定加锁顺序**，A->B->C 必须按照确定的顺序获取锁，就不会请求保持了。
4. **设置最长占用时间，设置个合理的超时时间**




### AQS
AQS：AbstractQueuedSynchronizer抽象的队列式同步器。
     
AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch



AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，当一个线程执行完毕（lock.unlock()）时会激活自己的后继节点，
但正在执行的线程并不在队列中，而那些等待执行的线程全部处于阻塞状态.

java.util.concurrent包（之后简称JUC包）中，提供了大量的同步与并发的工具类，是多线程编程的“利器”。其中locks包下，包含了多种锁，如ReentrantLock独占锁、ReentrantReadWriteLock读写锁、Semaphore信号量（共享锁）等，而这些锁有一个共同的基础类：AbstractQueuedSynchronizer。

AQS是一个抽象类，不可以被实例化，它的设计之初就是为了让子类通过继承来实现多样的功能的。它内部提供了一个FIFO的等待队列，用于多个线程等待一个事件（锁）。它有一个重要的状态标志——state，该属性是一个int值，表示对象的当前状态（如0表示lock，1表示unlock）。AQS提供了三个protected final的方法来改变state的值，分别是：getState、setState(int)、compareAndSetState(int, int)。根据修饰符，它们是不可以被子类重写的，但可以在子类中进行调用，这也就意味着子类可以根据自己的逻辑来决定如何使用state值。

AQS的子类应当被定义为内部类，作为内部的helper对象。事实上，这也是juc种锁的做法，如ReentrantLock，便是通过内部的Sync对象来继承AQS的。AQS中定义了一些未实现的方法（抛出UnsupportedOperationException异常）

tryAcquire(int) 尝试获取state

tryRelease(int) 尝试释放state

tryAcquireShared(int) 共享的方式尝试获取

tryReleaseShared(int) 共享的方式尝试释放

isHeldExclusively() 判断当前是否为独占锁

这些方法是子类需要实现的，可以选择实现其中的一部分。根据实现方式的不同，可以分为两种：独占锁和共享锁。其中JUC中锁的分类为:

独占锁：ReentrantLock、ReentrantReadWriteLock.WriteLock

共享锁：ReentrantReadWriteLock.ReadLock、CountDownLatch、CyclicBarrier、Semaphore

其实现方式为：

独占锁实现的是tryAcquire(int)、tryRelease(int)

共享锁实现的是tryAcquireShared(int)、tryReleaseShared(int)

#### 实现细节
AQS内部定义了一个static final的内部类Node，用于实现等待队列CLH，满足FIFO结构。
AQS还存放一个int类型的属性state，用于表示当前的同步状态。









