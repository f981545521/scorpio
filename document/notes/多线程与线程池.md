## 多线程与线程池
#### 线程池，线程池运作原理、线程池核心参数？cachePool 区别?

> Spring的：ThreadPoolTaskExecutor

- "corePoolSize"            核心线程池数量
- "maxPoolSize"            最大线程数量
- "queueCapacity"            线程池的队列容量
- "keepAliveSeconds"        存活时间（秒）

#### 说明
- corePoolSize : 表示线程池核心线程数，当初始化线程池时，会创建核心线程进入等待状态，即使它是空闲的，核心线程也不会被摧毁，从而降低了任务一来时要创建新线程的时间和性能开销。
- maximumPoolSize : 表示最大线程数，意味着核心线程数都被用完了，那只能重新创建新的线程来执行任务，但是前提是不能超过最大线程数量，否则该任务只能进入阻塞队列进行排队等候，直到有线程空闲了，才能继续执行任务。
- keepAliveTime : 表示线程存活时间，除了核心线程外，那些被新创建出来的线程可以存活多久。意味着，这些新的线程一但完成任务，而后面都是空闲状态时，就会在一定时间后被摧毁。
- unit : 存活时间单位，没什么好解释的，一看就懂。
- workQueue : 表示任务的阻塞队列，由于任务可能会有很多，而线程就那么几个，所以那么还未被执行的任务就进入队列中排队，队列我们知道是 FIFO 的，等到线程空闲了，就以这种方式取出任务。这个一般不需要我们去实现。


#### JDK中的使用
> JDK的：ExecutorService        Executors工厂去new
- ExecutorService newFixedThreadPool() :             创建固定大小的线程池
- ExecutorService newCachedThreadPool() :         缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。
- ExecutorService newSingleThreadExecutor() :     创建单个线程池。 线程池中只有一个线程
- ExecutorService newScheduledThreadPool() :     创建固定大小的线程，可以延迟或定时的执行任务
- ExecutorService newWorkStealingPool() :           工作窃取？



1. 当一个任务被提交到线程池时，首先查看线程池的核心线程是否都在执行任务。如果没有，则选择一条线程执行任务。
2. 如果都在执行任务，查看任务队列是否已满。如果不满，则将任务存储在任务队列中。核心线程执行完自己的任务后，会再处理任务队列中的任务。
3. 如果任务队列已满，查看线程池（最大线程数控制）是否已满。如果不满，则创建一条线程去执行任务。如果满了，就按照策略处理无法执行的任务。

#### 示例与说明
```
//指定：corePoolSize = 0、maximumPoolSize = Integer.MAX_VALUE 的线程池
//线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。
//创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();


//指定：corePoolSize、maximumPoolSize 的线程池
//(创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。)
ExecutorService fixedThreadPool = Executors.newFixedThreadPool(10);


//指定：corePoolSize、maximumPoolSize 为1的线程池
//**创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。**
ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();


//可以延迟和定期执行的线程池     (创建一个定长线程池，支持定时及周期性任务执行。)
ScheduledExecutorService  scheduledExecutor = Executors.newScheduledThreadPool(10);
scheduledExecutor.schedule(() -> System.out.println("ok"), 1, TimeUnit.DAYS);
//                                                                          初始延迟和周期执行
scheduledExecutor.scheduleAtFixedRate(() -> System.out.println("ok"), 2, 3, TimeUnit.HOURS);
//创建一个具有抢占式操作的线程池
/*
 *  * 假设共有三个线程同时执行, A, B, C
 *  * 当A,B线程池尚未处理任务结束,而C已经处理完毕,则C线程会从A或者B中窃取任务执行,这就叫工作窃取
 *  * 假如A线程中的队列里面分配了5个任务，而B线程的队列中分配了1个任务，当B线程执行完任务后，它会主动的去A线程中窃取其他的任务进行执行
 *  * WorkStealingPool 背后是使用 ForkJoinPool实现的
 */
//ForkJoinPool
ExecutorService workStealingExecutor = Executors.newWorkStealingPool(10);
```